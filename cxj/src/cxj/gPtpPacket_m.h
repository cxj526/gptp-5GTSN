//
// Generated file, do not edit! Created by nedtool 5.6 from src/cxj/gPtpPacket.msg.
//

#ifndef __CXJ_GPTPPACKET_M_H
#define __CXJ_GPTPPACKET_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include "omnetpp/simtime.h"
#include "omnetpp.h"
#include "inet/common/Units.h"
#include "inet/common/INETUtils.h"
#include "inet/common/INETDefs.h"
#include "inet/common/INETDefs_m.h"
#include "inet/common/packet/chunk/Chunk_m.h"
#include "inet/common/TagBase_m.h"
namespace cxj {
using namespace inet::units::values;
const B GPTP_SYNC_1STEP_PACKET_SIZE = B(76);
const B GPTP_SYNC_2STEP_PACKET_SIZE = B(44);
const B GPTP_FOLLOW_UP_PACKET_SIZE = B(76);
const B GPTP_PDELAY_REQ_PACKET_SIZE = B(54);
const B GPTP_PDELAY_RESP_PACKET_SIZE = B(54);
const B GPTP_PDELAY_RESP_FOLLOW_UP_PACKET_SIZE = B(54);
}
// }}


namespace cxj {

/**
 * Enum generated from <tt>src/cxj/gPtpPacket.msg:50</tt> by nedtool.
 * <pre>
 * enum GptpNodeType
 * {
 *     MASTER_NODE = 11;
 *     BRIDGE_NODE = 12;
 *     SLAVE_NODE = 13;
 * }
 * </pre>
 */
enum GptpNodeType {
    MASTER_NODE = 11,
    BRIDGE_NODE = 12,
    SLAVE_NODE = 13
};

/**
 * Enum generated from <tt>src/cxj/gPtpPacket.msg:57</tt> by nedtool.
 * <pre>
 * enum GptpPortType
 * {
 *     MASTER_PORT = 2;
 *     SLAVE_PORT = 1;
 *     PASSIVE_PORT = 0;
 * }
 * </pre>
 */
enum GptpPortType {
    MASTER_PORT = 2,
    SLAVE_PORT = 1,
    PASSIVE_PORT = 0
};

/**
 * Enum generated from <tt>src/cxj/gPtpPacket.msg:64</tt> by nedtool.
 * <pre>
 * enum GptpMessageType
 * {
 *     GPTPTYPE_SYNC = 1010;
 *     GPTPTYPE_FOLLOW_UP = 1011;
 *     GPTPTYPE_PDELAY_REQ = 1014;
 *     GPTPTYPE_PDELAY_RESP = 1012;
 *     GPTPTYPE_PDELAY_RESP_FOLLOW_UP = 1013;
 * }
 * </pre>
 */
enum GptpMessageType {
    GPTPTYPE_SYNC = 1010,
    GPTPTYPE_FOLLOW_UP = 1011,
    GPTPTYPE_PDELAY_REQ = 1014,
    GPTPTYPE_PDELAY_RESP = 1012,
    GPTPTYPE_PDELAY_RESP_FOLLOW_UP = 1013
};

/**
 * Enum generated from <tt>src/cxj/gPtpPacket.msg:72</tt> by nedtool.
 * <pre>
 * enum GptpSelfMsgKind
 * {
 *     GPTP_SELF_REQ_ANSWER_KIND = 101;
 *     GPTP_SELF_MSG_SYNC = 103;
 *     GPTP_REQUEST_TO_SEND_SYNC = 104;
 *     GPTP_SELF_MSG_PDELAY_REQ = 105;
 * }
 * </pre>
 */
enum GptpSelfMsgKind {
    GPTP_SELF_REQ_ANSWER_KIND = 101,
    GPTP_SELF_MSG_SYNC = 103,
    GPTP_REQUEST_TO_SEND_SYNC = 104,
    GPTP_SELF_MSG_PDELAY_REQ = 105
};

/**
 * Struct generated from src/cxj/gPtpPacket.msg:80 by nedtool.
 */
struct PortIdentity
{
    PortIdentity();
    uint64_t clockIdentity;
    uint16_t portNumber;
};

// helpers for local use
void __doPacking(omnetpp::cCommBuffer *b, const PortIdentity& a);
void __doUnpacking(omnetpp::cCommBuffer *b, PortIdentity& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PortIdentity& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PortIdentity& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>src/cxj/gPtpPacket.msg:87</tt> by nedtool.
 * <pre>
 * // ieee802.1AS-2020 11.4.2
 * class GptpBase extends inet::FieldsChunk
 * {
 *     int messageType \@enum(GptpMessageType);
 *     // uint16_t messageLength; // currently unused
 *     //uint8_t domainNumber; // currently unused
 *     // uint16_t flags; // currently unused
 *     omnetpp::simtime_t correctionField;
 *     PortIdentity sourcePortIdentity;
 *    // uint16_t sequenceId; // currently unused
 *    // uint8_t logMessageInterval; // currently unused
 * }
 * </pre>
 */
class GptpBase : public ::inet::FieldsChunk
{
  protected:
    int messageType;
    omnetpp::simtime_t correctionField;
    PortIdentity sourcePortIdentity;

  private:
    void copy(const GptpBase& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GptpBase&);

  public:
    GptpBase();
    GptpBase(const GptpBase& other);
    virtual ~GptpBase();
    GptpBase& operator=(const GptpBase& other);
    virtual GptpBase *dup() const override {return new GptpBase(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getMessageType() const;
    virtual void setMessageType(int messageType);
    virtual omnetpp::simtime_t& getCorrectionField();
    virtual const omnetpp::simtime_t& getCorrectionField() const {return const_cast<GptpBase*>(this)->getCorrectionField();}
    virtual void setCorrectionField(const omnetpp::simtime_t& correctionField);
    virtual PortIdentity& getSourcePortIdentity();
    virtual const PortIdentity& getSourcePortIdentity() const {return const_cast<GptpBase*>(this)->getSourcePortIdentity();}
    virtual void setSourcePortIdentity(const PortIdentity& sourcePortIdentity);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GptpBase& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GptpBase& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/cxj/gPtpPacket.msg:99</tt> by nedtool.
 * <pre>
 * class GptpSync extends GptpBase
 * {
 *     messageType = GPTPTYPE_SYNC;
 *     //flags = twoStepFlag;
 *     chunkLength = GPTP_SYNC_2STEP_PACKET_SIZE;
 *     omnetpp::simtime_t originTimestamp; // filled when twoStep flag is FALSE
 *     //omnetpp::simtime_t aaa;
 *     // followUpInformationTLV; // filled when twoStep flag is FALSE
 * }
 * </pre>
 */
class GptpSync : public ::cxj::GptpBase
{
  protected:
    omnetpp::simtime_t originTimestamp;

  private:
    void copy(const GptpSync& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GptpSync&);

  public:
    GptpSync();
    GptpSync(const GptpSync& other);
    virtual ~GptpSync();
    GptpSync& operator=(const GptpSync& other);
    virtual GptpSync *dup() const override {return new GptpSync(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual omnetpp::simtime_t& getOriginTimestamp();
    virtual const omnetpp::simtime_t& getOriginTimestamp() const {return const_cast<GptpSync*>(this)->getOriginTimestamp();}
    virtual void setOriginTimestamp(const omnetpp::simtime_t& originTimestamp);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GptpSync& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GptpSync& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/cxj/gPtpPacket.msg:109</tt> by nedtool.
 * <pre>
 * class GptpFollowUp extends GptpBase
 * {
 *     messageType = GPTPTYPE_FOLLOW_UP;
 *     chunkLength = GPTP_FOLLOW_UP_PACKET_SIZE;
 *     omnetpp::simtime_t preciseOriginTimestamp;  // 11.4.4.2.1
 *     // followUpInformationTLV:
 *     double rateRatio;  // 11.4.4.3.6 cumulativeScaledRateOffset, relative to GrandMaster
 *     // uint16_t gmTimeBaseIndicator;
 *     // ScaledNs lastGmPhaseChange;
 *     // int32_t scaledLastGmFreqChange;
 *     // ??? int numberOfHops;
 * }
 * </pre>
 */
class GptpFollowUp : public ::cxj::GptpBase
{
  protected:
    omnetpp::simtime_t preciseOriginTimestamp;
    double rateRatio;

  private:
    void copy(const GptpFollowUp& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GptpFollowUp&);

  public:
    GptpFollowUp();
    GptpFollowUp(const GptpFollowUp& other);
    virtual ~GptpFollowUp();
    GptpFollowUp& operator=(const GptpFollowUp& other);
    virtual GptpFollowUp *dup() const override {return new GptpFollowUp(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual omnetpp::simtime_t& getPreciseOriginTimestamp();
    virtual const omnetpp::simtime_t& getPreciseOriginTimestamp() const {return const_cast<GptpFollowUp*>(this)->getPreciseOriginTimestamp();}
    virtual void setPreciseOriginTimestamp(const omnetpp::simtime_t& preciseOriginTimestamp);
    virtual double getRateRatio() const;
    virtual void setRateRatio(double rateRatio);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GptpFollowUp& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GptpFollowUp& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/cxj/gPtpPacket.msg:122</tt> by nedtool.
 * <pre>
 * class GptpPdelayReq extends GptpBase
 * {
 *     messageType = GPTPTYPE_PDELAY_REQ;
 *     chunkLength = GPTP_PDELAY_REQ_PACKET_SIZE;
 *     omnetpp::simtime_t reserved1;
 *     omnetpp::simtime_t reserved2;
 * }
 * </pre>
 */
class GptpPdelayReq : public ::cxj::GptpBase
{
  protected:
    omnetpp::simtime_t reserved1;
    omnetpp::simtime_t reserved2;

  private:
    void copy(const GptpPdelayReq& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GptpPdelayReq&);

  public:
    GptpPdelayReq();
    GptpPdelayReq(const GptpPdelayReq& other);
    virtual ~GptpPdelayReq();
    GptpPdelayReq& operator=(const GptpPdelayReq& other);
    virtual GptpPdelayReq *dup() const override {return new GptpPdelayReq(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual omnetpp::simtime_t& getReserved1();
    virtual const omnetpp::simtime_t& getReserved1() const {return const_cast<GptpPdelayReq*>(this)->getReserved1();}
    virtual void setReserved1(const omnetpp::simtime_t& reserved1);
    virtual omnetpp::simtime_t& getReserved2();
    virtual const omnetpp::simtime_t& getReserved2() const {return const_cast<GptpPdelayReq*>(this)->getReserved2();}
    virtual void setReserved2(const omnetpp::simtime_t& reserved2);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GptpPdelayReq& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GptpPdelayReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/cxj/gPtpPacket.msg:130</tt> by nedtool.
 * <pre>
 * class GptpPdelayResp extends GptpBase
 * {
 *     messageType = GPTPTYPE_PDELAY_RESP;
 *     chunkLength = GPTP_PDELAY_RESP_PACKET_SIZE;
 *     omnetpp::simtime_t requestReceiptTimestamp;
 *     PortIdentity requestingPortIdentity;
 * }
 * </pre>
 */
class GptpPdelayResp : public ::cxj::GptpBase
{
  protected:
    omnetpp::simtime_t requestReceiptTimestamp;
    PortIdentity requestingPortIdentity;

  private:
    void copy(const GptpPdelayResp& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GptpPdelayResp&);

  public:
    GptpPdelayResp();
    GptpPdelayResp(const GptpPdelayResp& other);
    virtual ~GptpPdelayResp();
    GptpPdelayResp& operator=(const GptpPdelayResp& other);
    virtual GptpPdelayResp *dup() const override {return new GptpPdelayResp(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual omnetpp::simtime_t& getRequestReceiptTimestamp();
    virtual const omnetpp::simtime_t& getRequestReceiptTimestamp() const {return const_cast<GptpPdelayResp*>(this)->getRequestReceiptTimestamp();}
    virtual void setRequestReceiptTimestamp(const omnetpp::simtime_t& requestReceiptTimestamp);
    virtual PortIdentity& getRequestingPortIdentity();
    virtual const PortIdentity& getRequestingPortIdentity() const {return const_cast<GptpPdelayResp*>(this)->getRequestingPortIdentity();}
    virtual void setRequestingPortIdentity(const PortIdentity& requestingPortIdentity);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GptpPdelayResp& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GptpPdelayResp& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/cxj/gPtpPacket.msg:138</tt> by nedtool.
 * <pre>
 * class GptpPdelayRespFollowUp extends GptpBase
 * {
 *     messageType = GPTPTYPE_PDELAY_RESP_FOLLOW_UP;
 *     chunkLength = GPTP_PDELAY_RESP_FOLLOW_UP_PACKET_SIZE;
 *     omnetpp::simtime_t responseOriginTimestamp;
 *     PortIdentity requestingPortIdentity;
 * }
 * </pre>
 */
class GptpPdelayRespFollowUp : public ::cxj::GptpBase
{
  protected:
    omnetpp::simtime_t responseOriginTimestamp;
    PortIdentity requestingPortIdentity;

  private:
    void copy(const GptpPdelayRespFollowUp& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GptpPdelayRespFollowUp&);

  public:
    GptpPdelayRespFollowUp();
    GptpPdelayRespFollowUp(const GptpPdelayRespFollowUp& other);
    virtual ~GptpPdelayRespFollowUp();
    GptpPdelayRespFollowUp& operator=(const GptpPdelayRespFollowUp& other);
    virtual GptpPdelayRespFollowUp *dup() const override {return new GptpPdelayRespFollowUp(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual omnetpp::simtime_t& getResponseOriginTimestamp();
    virtual const omnetpp::simtime_t& getResponseOriginTimestamp() const {return const_cast<GptpPdelayRespFollowUp*>(this)->getResponseOriginTimestamp();}
    virtual void setResponseOriginTimestamp(const omnetpp::simtime_t& responseOriginTimestamp);
    virtual PortIdentity& getRequestingPortIdentity();
    virtual const PortIdentity& getRequestingPortIdentity() const {return const_cast<GptpPdelayRespFollowUp*>(this)->getRequestingPortIdentity();}
    virtual void setRequestingPortIdentity(const PortIdentity& requestingPortIdentity);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GptpPdelayRespFollowUp& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GptpPdelayRespFollowUp& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/cxj/gPtpPacket.msg:146</tt> by nedtool.
 * <pre>
 * class GptpIngressTimeInd extends inet::TagBase
 * {
 *     omnetpp::simtime_t arrivalClockTime;
 * }
 * </pre>
 */
class GptpIngressTimeInd : public ::inet::TagBase
{
  protected:
    omnetpp::simtime_t arrivalClockTime;

  private:
    void copy(const GptpIngressTimeInd& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GptpIngressTimeInd&);

  public:
    GptpIngressTimeInd();
    GptpIngressTimeInd(const GptpIngressTimeInd& other);
    virtual ~GptpIngressTimeInd();
    GptpIngressTimeInd& operator=(const GptpIngressTimeInd& other);
    virtual GptpIngressTimeInd *dup() const override {return new GptpIngressTimeInd(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual omnetpp::simtime_t& getArrivalClockTime();
    virtual const omnetpp::simtime_t& getArrivalClockTime() const {return const_cast<GptpIngressTimeInd*>(this)->getArrivalClockTime();}
    virtual void setArrivalClockTime(const omnetpp::simtime_t& arrivalClockTime);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GptpIngressTimeInd& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GptpIngressTimeInd& obj) {obj.parsimUnpack(b);}

} // namespace cxj

#endif // ifndef __CXJ_GPTPPACKET_M_H

